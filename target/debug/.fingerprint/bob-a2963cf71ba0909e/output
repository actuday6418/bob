{"message":"mismatched closing delimiter: `}`","code":null,"level":"error","spans":[{"file_name":"src/standard_function_declarations.rs","byte_start":6385,"byte_end":6386,"line_start":133,"line_end":133,"column_start":1,"column_end":2,"is_primary":true,"text":[{"text":"}","highlight_start":1,"highlight_end":2}],"label":"mismatched closing delimiter","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/standard_function_declarations.rs","byte_start":4524,"byte_end":4525,"line_start":93,"line_end":93,"column_start":128,"column_end":129,"is_primary":false,"text":[{"text":"pub fn variable_assigner(translated_file: &mut fs::File,argument_vector: Vec<String>,variable_stack: &mut Vec<crate::Variable>){","highlight_start":128,"highlight_end":129}],"label":"closing delimiter possibly meant for this","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/standard_function_declarations.rs","byte_start":4753,"byte_end":4754,"line_start":99,"line_end":99,"column_start":50,"column_end":51,"is_primary":false,"text":[{"text":"    if argument_vector[1] == \"be\".to_string() && (argument_vector[2] == \"a\" || argument_vector[2] == \"an\"{","highlight_start":50,"highlight_end":51}],"label":"unclosed delimiter","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: mismatched closing delimiter: `}`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/standard_function_declarations.rs:133:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m93\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0mpub fn variable_assigner(translated_file: &mut fs::File,argument_vector: Vec<String>,variable_stack: &mut Vec<crate::Variable>){\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                                                                                               \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mclosing delimiter possibly meant for this\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m99\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    if argument_vector[1] == \"be\".to_string() && (argument_vector[2] == \"a\" || argument_vector[2] == \"an\"{\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                 \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12munclosed delimiter\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m133\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m}\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mmismatched closing delimiter\u001b[0m\n\n"}
{"message":"expected one of `)`, `,`, `.`, `?`, or an operator, found `{`","code":null,"level":"error","spans":[{"file_name":"src/standard_function_declarations.rs","byte_start":4753,"byte_end":4754,"line_start":99,"line_end":99,"column_start":50,"column_end":51,"is_primary":false,"text":[{"text":"    if argument_vector[1] == \"be\".to_string() && (argument_vector[2] == \"a\" || argument_vector[2] == \"an\"{","highlight_start":50,"highlight_end":51}],"label":"unclosed delimiter","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/standard_function_declarations.rs","byte_start":4809,"byte_end":4810,"line_start":99,"line_end":99,"column_start":106,"column_end":107,"is_primary":true,"text":[{"text":"    if argument_vector[1] == \"be\".to_string() && (argument_vector[2] == \"a\" || argument_vector[2] == \"an\"{","highlight_start":106,"highlight_end":107}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`)` may belong here","code":null,"level":"help","spans":[{"file_name":"src/standard_function_declarations.rs","byte_start":4809,"byte_end":4809,"line_start":99,"line_end":99,"column_start":106,"column_end":106,"is_primary":true,"text":[{"text":"    if argument_vector[1] == \"be\".to_string() && (argument_vector[2] == \"a\" || argument_vector[2] == \"an\"{","highlight_start":106,"highlight_end":106}],"label":null,"suggested_replacement":"`)`","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: expected one of `)`, `,`, `.`, `?`, or an operator, found `{`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/standard_function_declarations.rs:99:106\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m99\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    if argument_vector[1] == \"be\".to_string() && (argument_vector[2] == \"a\" || argument_vector[2] == \"an\"{\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                 \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12munclosed delimiter\u001b[0m\u001b[0m                                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mhelp: `)` may belong here\u001b[0m\n\n"}
{"message":"expected expression, found `)`","code":null,"level":"error","spans":[{"file_name":"src/standard_function_declarations.rs","byte_start":6385,"byte_end":6386,"line_start":133,"line_end":133,"column_start":1,"column_end":2,"is_primary":true,"text":[{"text":"}","highlight_start":1,"highlight_end":2}],"label":"expected expression","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: expected expression, found `)`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/standard_function_declarations.rs:133:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m133\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m}\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected expression\u001b[0m\n\n"}
{"message":"cannot find value `variable_type` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src/standard_function_declarations.rs","byte_start":4885,"byte_end":4898,"line_start":101,"line_end":101,"column_start":31,"column_end":44,"is_primary":true,"text":[{"text":"    let variable_type = match variable_type.as_str(){","highlight_start":31,"highlight_end":44}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"a local variable with a similar name exists","code":null,"level":"help","spans":[{"file_name":"src/standard_function_declarations.rs","byte_start":4885,"byte_end":4898,"line_start":101,"line_end":101,"column_start":31,"column_end":44,"is_primary":true,"text":[{"text":"    let variable_type = match variable_type.as_str(){","highlight_start":31,"highlight_end":44}],"label":null,"suggested_replacement":"variable_name","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0425]\u001b[0m\u001b[0m\u001b[1m: cannot find value `variable_type` in this scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/standard_function_declarations.rs:101:31\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m101\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    let variable_type = match variable_type.as_str(){\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                              \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mhelp: a local variable with a similar name exists: `variable_name`\u001b[0m\n\n"}
{"message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code example:\n\n```compile_fail,E0308\nlet x: i32 = \"I am not a number!\";\n//     ~~~   ~~~~~~~~~~~~~~~~~~~~\n//      |             |\n//      |    initializing expression;\n//      |    compiler infers type `&str`\n//      |\n//    type `i32` assigned to variable `x`\n```\n\nThis error occurs when the compiler was unable to infer the concrete type of a\nvariable. It can happen in several cases, the most common being a mismatch\nbetween the type that the compiler inferred for a variable based on its\ninitializing expression, on the one hand, and the type the author explicitly\nassigned to the variable, on the other hand.\n"},"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":1832,"byte_end":1848,"line_start":71,"line_end":71,"column_start":90,"column_end":106,"is_primary":true,"text":[{"text":"        \"write\" => standard_function_declarations::write_to_stdout(false,translated_file,&query_vector[1],headers,variable_stack),","highlight_start":90,"highlight_end":106}],"label":"expected struct `std::vec::Vec`, found `&std::string::String`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected struct `std::vec::Vec<std::string::String>`\nfound reference `&std::string::String`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0308]\u001b[0m\u001b[0m\u001b[1m: mismatched types\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/lib.rs:71:90\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m71\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        \"write\" => standard_function_declarations::write_to_stdout(false,translated_file,&query_vector[1],headers,variable_stack),\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                                                         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected struct `std::vec::Vec`, found `&std::string::String`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: expected struct `\u001b[0m\u001b[0m\u001b[1mstd::vec::Vec<std::string::String>\u001b[0m\u001b[0m`\u001b[0m\n\u001b[0m           found reference `\u001b[0m\u001b[0m\u001b[1m&std::string::String\u001b[0m\u001b[0m`\u001b[0m\n\n"}
{"message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code example:\n\n```compile_fail,E0308\nlet x: i32 = \"I am not a number!\";\n//     ~~~   ~~~~~~~~~~~~~~~~~~~~\n//      |             |\n//      |    initializing expression;\n//      |    compiler infers type `&str`\n//      |\n//    type `i32` assigned to variable `x`\n```\n\nThis error occurs when the compiler was unable to infer the concrete type of a\nvariable. It can happen in several cases, the most common being a mismatch\nbetween the type that the compiler inferred for a variable based on its\ninitializing expression, on the one hand, and the type the author explicitly\nassigned to the variable, on the other hand.\n"},"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":1967,"byte_end":1983,"line_start":72,"line_end":72,"column_start":94,"column_end":110,"is_primary":true,"text":[{"text":"        \"write_line\" => standard_function_declarations::write_to_stdout(true,translated_file,&query_vector[1],headers,variable_stack),","highlight_start":94,"highlight_end":110}],"label":"expected struct `std::vec::Vec`, found `&std::string::String`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected struct `std::vec::Vec<std::string::String>`\nfound reference `&std::string::String`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0308]\u001b[0m\u001b[0m\u001b[1m: mismatched types\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/lib.rs:72:94\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m72\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        \"write_line\" => standard_function_declarations::write_to_stdout(true,translated_file,&query_vector[1],headers,variable_stack),\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                                                             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected struct `std::vec::Vec`, found `&std::string::String`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: expected struct `\u001b[0m\u001b[0m\u001b[1mstd::vec::Vec<std::string::String>\u001b[0m\u001b[0m`\u001b[0m\n\u001b[0m           found reference `\u001b[0m\u001b[0m\u001b[1m&std::string::String\u001b[0m\u001b[0m`\u001b[0m\n\n"}
{"message":"this function takes 3 arguments but 4 arguments were supplied","code":{"code":"E0061","explanation":"An invalid number of arguments was passed when calling a function.\n\nErroneous code example:\n\n```compile_fail,E0061\nfn f(u: i32) {}\n\nf(); // error!\n```\n\nThe number of arguments passed to a function must match the number of arguments\nspecified in the function signature.\n\nFor example, a function like:\n\n```\nfn f(a: u16, b: &str) {}\n```\n\nMust always be called with exactly two arguments, e.g., `f(2, \"test\")`.\n\nNote that Rust does not have a notion of optional function arguments or\nvariadic functions (except for its C-FFI).\n"},"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":2200,"byte_end":2215,"line_start":74,"line_end":74,"column_start":68,"column_end":83,"is_primary":false,"text":[{"text":"        \"let\" => standard_function_declarations::variable_assigner(translated_file,&query_vector[1],&query_vector[4],variable_stack),","highlight_start":68,"highlight_end":83}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/lib.rs","byte_start":2216,"byte_end":2232,"line_start":74,"line_end":74,"column_start":84,"column_end":100,"is_primary":false,"text":[{"text":"        \"let\" => standard_function_declarations::variable_assigner(translated_file,&query_vector[1],&query_vector[4],variable_stack),","highlight_start":84,"highlight_end":100}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/lib.rs","byte_start":2233,"byte_end":2249,"line_start":74,"line_end":74,"column_start":101,"column_end":117,"is_primary":false,"text":[{"text":"        \"let\" => standard_function_declarations::variable_assigner(translated_file,&query_vector[1],&query_vector[4],variable_stack),","highlight_start":101,"highlight_end":117}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/lib.rs","byte_start":2250,"byte_end":2264,"line_start":74,"line_end":74,"column_start":118,"column_end":132,"is_primary":false,"text":[{"text":"        \"let\" => standard_function_declarations::variable_assigner(translated_file,&query_vector[1],&query_vector[4],variable_stack),","highlight_start":118,"highlight_end":132}],"label":"supplied 4 arguments","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/standard_function_declarations.rs","byte_start":4397,"byte_end":4524,"line_start":93,"line_end":93,"column_start":1,"column_end":128,"is_primary":false,"text":[{"text":"pub fn variable_assigner(translated_file: &mut fs::File,argument_vector: Vec<String>,variable_stack: &mut Vec<crate::Variable>){","highlight_start":1,"highlight_end":128}],"label":"defined here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/lib.rs","byte_start":2150,"byte_end":2199,"line_start":74,"line_end":74,"column_start":18,"column_end":67,"is_primary":true,"text":[{"text":"        \"let\" => standard_function_declarations::variable_assigner(translated_file,&query_vector[1],&query_vector[4],variable_stack),","highlight_start":18,"highlight_end":67}],"label":"expected 3 arguments","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0061]\u001b[0m\u001b[0m\u001b[1m: this function takes 3 arguments but 4 arguments were supplied\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/lib.rs:74:18\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m74\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        \"let\" => standard_function_declarations::variable_assigner(translated_file,&query_vector[1],&query_vector[4],variable_stack),\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                 \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m----------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m----------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12msupplied 4 arguments\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                 \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                 \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected 3 arguments\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0msrc/standard_function_declarations.rs:93:1\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m93\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0mpub fn variable_assigner(translated_file: &mut fs::File,argument_vector: Vec<String>,variable_stack: &mut Vec<crate::Variable>){\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-------------------------------------------------------------------------------------------------------------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mdefined here\u001b[0m\n\n"}
{"message":"aborting due to 7 previous errors","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: aborting due to 7 previous errors\u001b[0m\n\n"}
{"message":"Some errors have detailed explanations: E0061, E0308, E0425.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1mSome errors have detailed explanations: E0061, E0308, E0425.\u001b[0m\n"}
{"message":"For more information about an error, try `rustc --explain E0061`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1mFor more information about an error, try `rustc --explain E0061`.\u001b[0m\n"}
